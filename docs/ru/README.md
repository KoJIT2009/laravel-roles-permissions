# Роли и разрешения для Laravel (RBAC)

* [Описание](#описание)
* [Установка](#установка)
* [Использование](#использование)
  * [Создание, удаление, наследование ролей и разрешений](#создание-удаление-наследование-ролей-и-разрешений)
  * [Наделение пользователей полномочиями](#наделение-пользователей-полномочиями)
  * [Проверка на допуски с помощью трейта](#проверка-на-допуски-с-помощью-трейта)
  * [Проверка на допуски с помощью шлюзов (gate)](#проверка-на-допуски-с-помощью-шлюзов-gate)
  * [Проверка на допуски с помощью посредников (middleware)](#проверка-на-допуски-с-помощью-посредников-middleware)
  * [Проверка на допуски с помощью директив шаблонизатора Blade](#проверка-на-допуски-с-помощью-директив-шаблонизатора-blade)
  * [Консольные команды Artisan управления RBAC](#консольные-команды-artisan-управления-rbac)
* [Продвинутое использование](#продвинутое-использование)
* [Кеширование](#кеширование)
* [Структура таблиц](#структура-таблиц)

## Описание

Laravel уже имеет по умолчанию ACL для управления доступом. Однако, если вам
необходимо построить систему разделения прав на основе ролей и/или разрешений для пользователей,
учитывая наследование прав, снабдить их дополнительной логикой, да ещё и хранить это в базе данных,
стандартного функционала будет недостаточно. Данное расширение RBAC является простым, но достаточно мощным
средством для реализации управления доступом в Laravel.

### Что поддерживает данное расширение?

- Различные модели могут обладать ролями, разрешениями (permissions) (Множественные модели пользователей).
- Бесконечная вложенность (наследование) для ролей и рарешений с проверкой на зациклинность прав.
- Множественные роли для пользователей
- Возмоность расширения типов элементов допуска (роли, разрешения, ...) например для разделения их по различным
guard
- Задание логики срабатывания прав (см.[Продвинутое использование](#продвинутое-использование))
- Проверка ролей, разрешений как по их названию, так и по id или объекту
- Проверка прав доступа через trait, gate, middleware, blade 
- Включение/Отключение кеширования
- Artisan-команды для управления RBAC

## Установка

Выполните команду композера для установки пакета:
```bash
composer require centeron/laravel-roles-permissions
```

Опубликуйте конфигурацию командой:
```bash
php artisan vendor:publish --provider="Centeron\Permissions\ServiceProvider" --tag="config"
```
После выполнения этой команды в появившемся файле `config/permissions.php` можете поменять названия
таблиц, используемых расширением, включить и настроить кеш.

Опубликуйте миграции командой:
```bash
php artisan vendor:publish --provider="Centeron\Permissions\ServiceProvider" --tag="migrations"
```

Запустите миграции:
```bash
php artisan migrate
```

## Использование

Добавьте трейт `Centeron\Permissions\Traits\HasAuthItems` к модели (моделям) пользователей `User`

```php
use Illuminate\Foundation\Auth\User as Authenticatable;
use Centeron\Permissions\Traits\HasAuthItems;

class User extends Authenticatable
{
    use HasAuthItems;

    // ...
}
```

Теперь пользователь добавлять себе роли, разрешения, проверять их наличие и т.д. Каждый пользователь может обладать
множеством ролей и разрешений. Разрешения могут прикрепляться к ролям, напрямую к пользователям, а также к другим родительским разрешеням.
Такие же возможности доступны и для ролей. Фактически, существенной разницы между ролями и разрешениями нет. Это условное разделение элементов
доступа на логические типы. Вы можете создавать свои собственные при необходимости. 

### Создание, удаление, наследование ролей и разрешений

Добавление ролей и разрешений производится следующим образом:
```php
use Centeron\Permissions\Models\AuthItem;

$role = AuthItem::createRole(['name' => 'admin']);
$role = AuthItem::create(['name' => 'admin', 'type' => AuthItem::TYPE_ROLE]); // альтернатива предыдущей записи

$permission = AuthItem::createPermission(['name' => 'admin']);
$permission = AuthItem::create(['name' => 'admin', 'type' => AuthItem::TYPE_PERMISSION]); // альтернатива предыдущей записи

```
Модель `AuthItem` является расширенной Eloquent моделью. Соответственно, вы можете использовать стандартные методы управления записями, в том числе и удаление:

```php
use Centeron\Permissions\Models\AuthItem;

AuthItem::where('name', 'admin')->delete();
```

С помощью методов `addChilds` и `addParents` вы можете добавлять дочерние и родительские элементы, организовывая иерархию произвольного уровня вложенности:

```php
$role->addChilds($permission1, $permission2, $subRole);
$permission2->addChilds($permission2_1);
$permission2_1_1->addParents($permission2_1);
```

Аналогично методы `removeChilds` и `removeParents` убирают эту зависимость (но не удаляя сами сущности `AuthItem`).

В данном примере переменные являются объектами класса `AuthItem`. Однако, в качестве параметров функции могут быть как объекты,
так и названия ролей/разрешений, и даже их ID. Функция сама определит, что ей передали по типу переданного параметра (int/string/class). Т.е.
возможна следующая запись:

```php
$permission = AuthItem::where('name', 'Create post')->first();

$role->addChilds($permission, 'Update post', 4);
$role->removeParents($permission, 4);
```

Проверить обладает ли элемент правами другого элемента (Другими словами: является ли он его потомком в каком-либо поколении)
можно с помощью функций `hasAny` (есть какой-либо из переданных) и `hasAll`(есть все переданные). Само собой, эти функции равнозначны
если количество передаваемых параметров равно 1.

```php
$hasAny = $role->hasAny('Update post', 4); // true, т.к. разрешение с именем 'Update post' присутствует
$hasAll = $role->hasAll('Update post', 4); // false, т.к. разрешение с ID=4 отсутствует. 
```

### Наделение пользователей полномочиями

Наделение моделей полномочиями может происходить как со стороны моделей, использующих трейт `Centeron\Permissions\Traits\HasAuthItems`:

```php
$user->attachAuthItems('admin', $otherRoleModel, 'Create post', 4); 
```

, так и со стороны самих ролей и разрешений, передавая в качестве параметров модели:

```php
$otherRoleModel->attach($user)
```
Лишить пользователя полномочий можно с помощью фукнции `detachAuthItems`:

```php
$user->detachAuthItems('Create post'); 
```

### Проверка на допуски с помощью трейта

Проверить обладает ли пользователь разрешением (-ми) можно так:

```php
$user->hasAnyAuthItems('View post', 'Edit post'); // true, если обладает любым разрешением
$user->hasAllAuthItems('View post', 'Edit post'); // true, если обладает всеми разрешениями
```

Однако, может быть случай, например, когда пользователь имеет возможность редактировать только свои статьи, или при условии
обладания определенного рейтинга. В этих ситуациях мы должны использовать другие фукнции, которые первым аргументом принимают
роль/разрешение или массив ролей/разрешений, а вторым дополнительный параметр или массив дополнительных параметров:

```php
$user->canAnyAuthItems(['View post', 'Edit post'], [1]); // true, если может смотреть или редактировать статью с ID = 1
$user->hasAllAuthItems(['View post', 'Edit post'], [1]); // true, если может смотреть и редактировать статью с ID = 1
```
Подробней о работе с условными допусками в разделе [Продвинутое использование](#продвинутое-использование)

### Проверка на допуски с помощью шлюзов (gate)

Стандартный способ проверки правил с помощью шлюза Gate также работает. Вы по-прежнему можете использовать методы
`check`, `allow` и `denies` фасада `Gate`

```php
      if (Gate::denies('Edit post', $post)) {}
      if (Gate::allows('Delete comment', [$post, $comment])) {}
      if (Gate::check('admin')) {}      
```

Определять допуски функцией `define` теперь нет необходимости. Они все хранятся в базе данных. Наследование прав от потомков
также учитывается.

В контроллерах вы также можете использовать хелпер

```php
    $this->authorize('Edit post', $post);
```

#### Проверка на допуски с помощью посредников (middleware)

На уровне маршрутов можно использовать `middleware`. Например:

```php
Route::match(['get', 'post'], 'post/view', 'PostController@view')->middleware('can:View post');
```

### Проверка на допуски с помощью директив шаблонизатора Blade

Во `view` файлах удобнее всего использовать директивы шаблонизатора:

```php
@authHasAny('Edit post', 'View post')
    // Отображение информации если текущий пользователь может просматривать или редактировать статью 
@authEnd

@authHasAll('Edit post', 'View post')
    // Отображение информации если текущий пользователь может просматривать и редактировать статью 
@authElse
    // В противном случае
@authEnd
```
Для условных допусков необходимо использовать слеующие директивы:

```php
@authCanAny(['Edit post', 'View post'], [1])
    // Отображение информации если текущий пользователь может просматривать или редактировать статью c ID=1
@authEnd

@authCanAll(['Edit post', 'View post'], [1])
    // Отображение информации если текущий пользователь может просматривать и редактировать статью с ID=1
@authElse
    // В противном случае
@authEnd
```
Подробней о работе с условными допусками в разделе [Продвинутое использование](#продвинутое-использование)

### Консольные команды Artisan управления RBAC

В текущем расширении представлен полный набор необходимых консольных команд для управления системой контроля
доступа. 

```php
php artisan centeron:auth-item-create // Create a new auth item (role or description)
php artisan centeron:auth-items-remove // Remove auth items (roles and permissions)
php artisan centeron:auth-item-inherit // Add child items to chosen auth item
php artisan centeron:auth-item-disinherit // Remove childs from an auth item
php artisan centeron:auth-items-attach // Attach the auth item to the model
php artisan centeron:auth-items-detach // Deattach auth items from the model
```

## Продвинутое использование

В большинестве случае работа с RBAC не требует какой-либо логики срабатывания разрешений. Мы помечаем области неким
идентификатором и затем проверяем: обладает ли пользователь соответствующими правами для доступа к этой области. Однако, 
иногда этого недостаточно. Что если пользователю нужно иметь возможность редактировать только свои статьи или статьи
определенных категорий? Причем новые категории могут появляться с течением времени, и мы не должны корректировать код,
расставляя новые идентификаторы каждый раз, когда появляется новая категория.

Учитывая всё выше сказанное, можно прийти к заключению, что разрешения должны иметь во-первых, возможность 
срабатывания по определеннм правилам (условный допуск) и, во-вторых, хранить некий набор данных, которые могут понадобиться при 
обработке согласно этому алгоритму. 

Для этих целей `Centeron\Permissions\Models\AuthItem` имеет 2 свойтсва:

* `rule` - хранит название класса, отвечающего за логику срабатывания
* `data` - хранит данные в сериализованном виде, которые могут понадобиться при работе с текущим объектом.

Правило `rule` представляет из себя ничто иное, как класс, реализующий контракт `Centeron\Permissions\Contracts`, 
который имеет единственный метод `handle`. В случае, если метод возвращает `true` объект `AuthItem` считается активным,
если `false`, то разрешение игнорируется.

В качестве примеров текущее расширение имеет 3 правила обработки разрешений:

**Допуск по текущему разрешению `authItem` доступен только в будние дни:**

```php
namespace Centeron\Permissions\Rules;

use Centeron\Permissions\Contracts\Rule;

class OnWeekdDays implements Rule
{
    public function handle($authItem, $model, $params = []): bool
    {
        return date('N') <= 5;
    }
}
```
**Пользователь имеет допуск только к объектам, где он является создателем:**

```php
namespace Centeron\Permissions\Rules;

use Centeron\Permissions\Contracts\Rule;

class OnWeekdDays implements Rule
{
    public function handle($authItem, $model, $params = []): bool
    {
       $entityId = $params[0] ?? null;
       return $model->id === $entityId;
    }
}
```
В текущем случае мы должны передать в правило информацию об объекте (его ID) в качетве параметра.

**Пользователь имеет допуск только к определенным категориям, указанным в БД:**

```php
namespace Centeron\Permissions\Rules;

use Centeron\Permissions\Contracts\Rule;

class OnWeekdDays implements Rule
{
    public function handle($authItem, $model, $params = []): bool
    {
        $myCategories = unserialize($authItem['data']);
        return array_intersect($params, $myCategories) ? true : false;
    }
}
```
В текущем случае мы должны передать информацию о категории в качестве параметра, а также
сохранить информацию в поле `data`, о категориях допуск к которым разрешен, согласно текущего правила.

Разумеется, каждый пользователь может обладать своим собственным набором категорий. В этой ситуации не обзятаельно создавать
новый `AuthItem` с новым набором `data` и текущим `rule` для каждого пользователя. Вы можете хранить данные во внешней таблице
и передавать их наряду с информцаией об объекте в качестве параметров.

Проверки на допуск к условным разрешениям мы производим не с помощью функций `hasAnyAuthItems` и `hasAllAuthItems`, а с
помощью `canAnyAuthItems` и `canAllAuthItems`, которые принимают в качестве аргументов два параметра: 
первым аргументом является роль/разрешение или массив ролей/разрешений, а вторым массив дополнительных параметров: 

```php
$user->canAnyAuthItems(['View post', 'Edit post'], [1]); // true, если может смотреть или редактировать статью с ID = 1
$user->hasAllAuthItems(['View post', 'Edit post'], [1]); // true, если может смотреть и редактировать статью с ID = 1
```

Также с помощью одной команды `canAuthItems` трейта можете узнать, какими правами из перечисленных обладает пользователь, а
какими нет.

Директивы blade также работают учитвая правила. Анлогично с методом `authorize` и методам фасада `Gate`.

**Разделение прав между пользователями по параметрам**

Поле `base_auth_id` в объекте `AuthItem` не обязательно для заполнения, и предназначено для связи с другим `AuthItem`, 
который, в свою очредь, является базовым. Методы `canAuthItems`, `canAnyAuthItems`, `canAllAuthItems` производят проверку
 не только по переданным допускам (и всех их дочерних иерархий), но и по связанным через `base_auth_id` допускам. 
 
 Примером может быть сиутация когда пользователям нужно предоставить допуск только к своим папкам файлового менеджера. 
 В качестве допуска к папкам файлового менеджера выступает, например, прописанный в коде `AuthItem` c `ID=1` и названием `Folder View`.
  Всё, что нам нужно сделать - это создать новые допуски `AuthItem` для каждого пользователя,
  с указанием названий папок в поле `data`, общего правила ограничения в поле `rule`, и установить `base_auth_id` равным 1 (ID `Folder View`).
   
   Теперь при попытке доступа к папке `folder_name` файлового менеджера посредством `$user->canAnyAuthItems(['Folder View'], ['folder_name']);`
   будет произведена проверка не только самого `Folder View`, но и других записей с `base_auth_id = 1`, сверки переданного параметра
   `folder_name` с данными `data` `AuthItem` посредством правила `rule`. 

### Кеширование

Несмотря на относительно большое количество запросов (от 3 до 5 в зависимости от ситуации)
проверка на допуск осуществляется невероятно быстро ввиду простоты этих запросов к БД (select из таблицы по индексам). Кеш, 
сохраняет содержимое каждой из трех таблиц.

Каждое изменение содержимого таблиц посредством любого из представленных методов работы с RBAC будет сбрасывать кеш. Сбросить кеш
можно также вручную:

```php
php artisan cache:forget centeron.permissions
```
Включить/отключить кеш, установить время жизни, его идентификатор можно в конфигурационном файле `config/permissions.php`.

Обращаем внимание. В случае когда приложение имеет сотни или тысячи различных допусков и их связей с пользователями, объем используемой
памяти во время проверки на допуски может достигать несколько мегабайт, т.к. производится кеширование информации со всех таблиц. 
Время обработки останется примерно тем же. В то же время, работа с отключенным кешем не производит значительного потребления дополнительной памяти
даже при большом количестве авторизационных данных в виду смены логики запросов к таблицам БД с полной выборки к выборке только
тех данных, которые необходимы исключительно для текущей проверки.

### Структура таблиц

Для организации работы текущего расширения достаточно всего 3 таблицы:

* `auth_items` - роли и разрешения
* `auth_item_childs` - информация о дочерних элементов ролей и разрешений
* `auth_assignments` - связи ролей и разрешений с пользователями (моделями)

Названия таблиц также можно поменять в конфигруационном файле `config/permissions.php` перед запуском миграций.

![Структура таблиц](https://github.com/centeron/laravel-roles-permissions/blob/master/docs/db.png)
